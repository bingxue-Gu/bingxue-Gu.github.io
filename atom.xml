<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-03T15:15:23.079Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计-Linux内核</title>
    <link href="http://example.com/2021/10/03/[OS]%E8%AE%BE%E8%AE%A1Linux/"/>
    <id>http://example.com/2021/10/03/[OS]%E8%AE%BE%E8%AE%A1Linux/</id>
    <published>2021-10-03T15:00:00.000Z</published>
    <updated>2021-10-03T15:15:23.079Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p>“<em>假如你是一个汽车工程师，或者还在学习造汽车的技术，那如果业界有这么一款汽车，性能稳定，设计思想优秀，而且不断在改进，汽车内部一些模块的实现方式甚至成为了业界标准，不仅如此，这款汽车的内部所有详细的技术资料都可以免费获取，也正因为如此，市面上也萌生了超级多的 Linux 发动机构造详解，深入理解 Linux 悬挂系统，你觉得你需不需要学习这款汽车？”</em></p><h5 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h5><blockquote><p>Linux,全称GNU/ Linux,是一套<strong>免费使用和自由传播</strong>的操作系统,支持类UNIX、POSX标准接口,也支持多用户、多进程、多线程,可以在多CPU的机器上运行</p><h6 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h6><blockquote><p>每个文件都有确定的用途,包括用户数据、命令配置参数、硬件设备等</p><p>对于操作系统内核而言,都被视为<strong>各种类型的文件</strong></p><p>Linux支持<strong>多用户</strong>,各个用户对于自己的文件有自己特殊的权利,保证了各用户之间互不影响。多任务则是现代操作系统最重要的一个特点, Linux可以使多个程序同时并独立地运行</p></blockquote><p>内部结构</p><p><img src="/img/OS-4/4-0.png" alt="4-0"></p><p>重要组件</p><p><img src="/img/OS-4/4-1.jpg" alt="4-1"></p><ul><li>宏内核</li></ul><p> Linux多模块挤在一起,之间的通信主要是<strong>函数调用</strong>,而且函数间的调用没有一定的层次关系,更加没有左右边界的限定</p></blockquote><h5 id="Darwin-XNU内核"><a href="#Darwin-XNU内核" class="headerlink" title="Darwin-XNU内核"></a>Darwin-XNU内核</h5><blockquote><p>Darwin是由苹果公司在2000年开发的一个开放源代码的操作系统</p><p>Darwin使用了一种微内核(Mach)和相应的固件来支持不同的处理器平台(Powerpc、x86、ARM架构的处理器),并提供操作系统原始的基础服务,上层的功能性系统服务和工具则是整合了BSD系统所提供的。苹果公司还为其开发了大量的库、框架和服务,不过它们都工作在用户态且闭源</p><p><img src="/img/OS-4/4-2.jpg" alt="4-2"></p><h6 id="Mach-amp-BSD"><a href="#Mach-amp-BSD" class="headerlink" title="Mach &amp; BSD"></a>Mach &amp; BSD</h6><blockquote><p>Mach内核是卡耐基梅隆大学开发的经典微内核,意在提供最基本的操作系统服务,从而达到高性能、安全、可扩展的目的,而BSD则是伯克利大学开发的类UNX操作系统,提供一整套操作系统服务</p><p>Mach内核仍然提供十分简单的<strong>进程、线程、IPC通信、虚拟内存设备驱动相关的功能服务</strong>,BSD则提供强大的<strong>安全特性,完善的网络服务,各种文件系统的支持</strong>,同时对Mach的进程、线程、IPC、虚拟内核组件进行细化、扩展延伸</p><p>[Why]</p><p>MAC OS X(2011年之前的称呼)的发展经过了不同时期,随着时代的进步,产品功能需求增加,单纯的Mach之上实现出现了性能瓶颈,但是为了兼容之前为Mach开 发的应用和设备驱动,就保留了Mach内核,同时加入了BSD内核</p><p>[How]</p><p>在调用 Darwin系统API时,会传入ー个API号码,用这个号码去索引Mach陷入中 断服务表中的函数</p><p>API号码如果小于0,则表明请求的是Mach内核的服务,<br>API号码如果大于0,则表明请求的是BSD内核的服务,它提供一整套标准的 POSIX接口</p><p>[*Libkern]</p><p>Mach中还有一个重要的组件 Libkern,它是一个库,提供了很多底层的操作函数,同时支持C++运行环境<br>依赖这个库的还有<strong>IOKit</strong>,IOKit管理所有的设备驱动和内核功能扩展模块。驱动程序开发人员则可以使用C++面向对象的方式开发驱动,这个方式很优雅,你完全可以找成熟的驱动程序作为父类继承它,要特别实现某个功能就重载其中的函数,也可以同时继承其它驱动程序,这大大节省了内存,也大大降低了出现BUG的可能</p></blockquote></blockquote><h5 id="Windows-NT内核"><a href="#Windows-NT内核" class="headerlink" title="Windows NT内核"></a>Windows NT内核</h5><blockquote><p>Windows NT是微软于1993年推出的面向工作站、网络服务器和大型计算机的网络操作系统,也可做PC操作系统。它是一款全新人零开始开发的新操作系统,并应用了现代硬件的所有特性,“NT”所指的便是“新技术”( New Technology)</p><p><img src="/img/OS-4/4-3.jpg" alt="4-3"></p><h6 id="小内核"><a href="#小内核" class="headerlink" title="小内核"></a>小内核</h6><blockquote><p>[小内核之下] 是硬件抽象层HAL(不同的硬件平台只要提供对应的HAL就可以移植系統了)</p><p>[小内核之上] 是各种内核组件,微软称之为<strong>内核执行体</strong>,它们完成<strong>进程、内存、配置、I/O文件、缓存、电源与即插即用、安全</strong>等相关的服务<br>每个执行体互相独立,只对外提供相应的接口,其它执行体要通过内核模式可调用接口和其它执行体通信或者请求其完成相应的功能服务。所有的设备驱动和文件系统都由I/O管理器统一管理,驱动程序可以堆叠形成I/O驱动栈,功能请求被封装成I/O包在栈中一层层流动处理。 Windows引以为做的图形子系统也在内核中。</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;/p&gt;
&lt;p&gt;“&lt;em&gt;假如你是一个汽车工程师，或者还在学习造汽车的技术，那如果业界有这么一款汽车，性能稳定，设计思想优秀，而且不断在改进，汽车内部一些模块的实现方式甚至成为了业界标准，不仅如此，这款汽车</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>设计-内核分层</title>
    <link href="http://example.com/2021/10/03/[OS]%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/10/03/[OS]%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-10-03T13:00:00.000Z</published>
    <updated>2021-10-03T13:44:04.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"><br><em>开发操作系统内核就像建房子 样,房子要建得好,就先要设计。比如用什么结构,什么材料,房间怎么布局,电路 水路等,最后画出设计图纸,依据图纸按部就班地进行建造</em></p><h5 id="计算机资源"><a href="#计算机资源" class="headerlink" title="计算机资源"></a>计算机资源</h5><blockquote><p>从抽象角度来看,内核就是 [<strong>计算机资源的管理者</strong>] ,当然管理资源是为了 [<strong>让应用使用资源</strong>]</p><ul><li>硬件资源</li></ul><p>1.总线,负责连接各种其它设备,是其它设备工作的基础。<br>2.CPU,即中央处理器,负责执行程序和处理数据运算。<br>3.内存,负责储存运行时的代码和数据。<br>4.硬盘,负责长久储存用户文件数据。<br>5.网卡,负责计算机与计算机之间的通信。<br>6.显卡,负责显示工作。<br>7.各种IO设备,如显示器,打印机,键盘,鼠标等。</p><p><img src="/img/OS-3/3-1.jpg" alt="3-1"></p><ul><li>软件资源</li></ul><p>而计算机中的软件资源,则可表示为计算机中的各种形式的[数据]如各种文件、软件程序等</p></blockquote><h5 id="内核组件（管理资源）"><a href="#内核组件（管理资源）" class="headerlink" title="内核组件（管理资源）"></a>内核组件（管理资源）</h5><blockquote><ul><li>管理CPU, 由于CPU是执行程序的,而内核把运行时的程序抽象成进程,所以又称为 [<strong>进程管理</strong>]</li><li>管理内存,由于程序和数据都要占用内存,内存是非常宝贵的资源,所以内核要非常小 心地分配、释放内存</li><li>管理硬盘,而硬盘主要存放用户数据,而内核把用户数据抽象成文件,即管理文件,文件需要合理地组织,方便用户查找和读写,所以形成了 <strong>[文件系统]</strong></li><li>管理显卡,负责显示信息,而现在操作系统都是支持GU(图形用户接口)的,管理显卡自然而然地就成了内核中的图形系统</li><li>管理网卡,网卡主要完成网络通信,网络通信需要各种通信协议,最后在内核中就形成了 <strong>[网络协议栈]</strong>,又称网络组件</li><li>管理各种I/O设备,我们经常把键盘、鼠标、打印机、显示器等统称为IO(输入输出)设备,在内核中抽象成IO管理器</li></ul><p>(内核除了这些必要组件之外,根据功能不同还有安全组件等,最值得一提的是,各种计算机硬件的性能不同,硬件型号不同,硬件种类不同,硬件厂商不同,内核要想管理和控制 这些硬件就要编写对应的代码,通常这样的代码我们称之为[<strong>驱动程序</strong>] )</p></blockquote><h5 id="经典的内核结构（组件组织方式）"><a href="#经典的内核结构（组件组织方式）" class="headerlink" title="经典的内核结构（组件组织方式）"></a>经典的内核结构（组件组织方式）</h5><blockquote><h6 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h6><blockquote><p>宏内核就是把以上诸如管理进程的代码、管理内存的代码、管理各种/O设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码,把这些所有的代码经过编译,最 后链接在一起,形成一个”大的可执行程序”</p><ul><li>API </li></ul><p>这个大程序里有实现支持这些功能的所有代码,向用户应用软件提供一些接口,这些接口就是常说的系统API函数。</p><ul><li>特权模式</li></ul><p>而这个大程序会在处理器的特权模式下运行,这个模式通常被称为**宏内核模式</p><hr><p>[服务过程-简]</p><p>1.应用程序调用内存分配的API(应用程序接口)函数<br>2.处理器切换到<strong>特权模式</strong>,开始运行内核代码<br>3.内核里的<strong>内存管理</strong>代码按照特定的算法,分配一块内存<br>4.把分配的内存块的首地址,返回给内存分配的API函数<br>5.内存分配的API函数返回,处理器开始运行<strong>用户模式</strong>下的应用程序,应用程序就得到了一块内存的首地址,并且可以使用这块内存了</p><p>性能好｜ 可拓展性差</p></blockquote><h6 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h6><blockquote><p>微内核架构正好与宏内核架构相反,它提倡内核功能尽可能少:仅仅只有进程调度、处理中断、内存空间映射、进程间通信等功能</p><ul><li>服务进程</li></ul><p>开发者们把实际的进程管理、内存管理、设备管 理、文件管理等服务功能,做成一个个服务进程。和用户应用进程一样,只是它们很特殊,宏内核提供的功能,在微内核架构里由这些服务进程专门负责完成</p><ul><li>消息机制</li></ul><p>微内核定义了一种良好的进程间通信的机制——消息</p><p>应用程序要请求相关服务,就向微 内核发送一条与此服务对应的消息,<strong>微内核再把这条消息转发给相关的服务进程</strong>,接着服务进程会完成相关的服务</p><p>服务进程的编程模型就是循环处理来自其它进程的消息,完成相关的服务功能</p><hr><p>[服务过程-简]</p><p>1.应用程序发送<strong>内存分配的消息</strong>,这个发送消息的函数是微内核提供的,相当于系统API,微内核的API(应用程序接口)相当少,极端情況下仅需要两个,一个接收消息的API和一个发送消息的API<br>2.处理器切换到<strong>特权模式</strong>,开始运行内核代码。<br>3.微内核代码让当前进程停止运行,并根据消息包中的数据,确定消息发送给谁,分配内存的消息当然是发送给内存管理服务进程<br>4.内存管理服务进程收到<strong>消息</strong>,分配一块内存<br>5.内存管理服务进程,也会通过消息的形式返回分配内存块的地址给内核,然后继续等待下一条<strong>消息</strong><br>6.微内核把包含内存块地址的<strong>消息</strong>返回给发送内存分配消息的应用程序<br>7.处理器开始运行<strong>用户模式</strong>下的应用程序,应用程序就得到了一块内存的首地址,并且可 以使用这块内存了</p><p>性能差｜ 可拓展性好</p></blockquote></blockquote><h5 id="分离硬件相关性"><a href="#分离硬件相关性" class="headerlink" title="分离硬件相关性"></a>分离硬件相关性</h5><blockquote><p>庞杂的计算机,其实也是一层一层地构建起来的,从硬件层到操作系统层再到应用软件层这样构建</p><p><em>分层的主要目的和好处在于屏蔽底层细节,使上层开发更加简单</em></p><ul><li>分离硬件的相关性</li></ul><blockquote><p>把<strong>操作硬件和处理硬件</strong>功能差异的代码抽离出来,形成一个独立的软件抽象层,对外提供相应的接口,方便上层开发</p></blockquote><ul><li>进程（例子）</li></ul><blockquote><p><em>一般操作系统理论课程都会花大量篇幅去讲进程相关的概念,其实说到底,<strong>进程是操作系统开发者为了实现多任务而提出的</strong>,并让每个进程在CPU上运行一小段时间,这样就能实现多任务同时运行的假象</em></p><ul><li>两种机制</li></ul><blockquote><p>[进程调度] 它的目的是要从众多进程中选择一个将要运行的进程,当然有各种选择的算法,例如,轮转算法、优先级算法等<br>[进程切换] 它的目的是停止当前进程,运行新的进程,主要动作是保存当前进程的机器上下文,装载新进程的机器上下文</p></blockquote><p>不管是在ARM硬件平台上还是在x86硬件平台上,选择一个进程的算法和代码是不容易发生改变的,需要改变的代码是<strong>进程切换的相关代码</strong>,因为不同的硬件平台的机器上下文是不同的</p></blockquote><ul><li>硬件平台相关层</li></ul><blockquote><p>如果把所有硬件平台相关的代码,都抽离出来,放在一个独立硬件相关层中实现并且定义好相关的<strong>调用接口</strong>,再在这个层之上开发内核的其它功能代码,就会方便得多,结构也会清晰很多。操作系统的<strong>移植性</strong>也会大大增强,移植到不同的硬件平台时,就构造开发一个 与之对应的硬件相关层</p></blockquote></blockquote><h5 id="设计"><a href="#设计" class="headerlink" title="*设计"></a>*设计</h5><blockquote><h6 id="内核接口层"><a href="#内核接口层" class="headerlink" title="内核接口层"></a>内核接口层</h6><blockquote><p>内核接口层,定义了一系列接口,主要有两点内容,如下<br>[UINX接口的子集]出于学习和研究的目的,使用UNX接口的子集,优点之一是接口少,只有几个,并且这几个接口又能大致定义出操作系统的功能<br>[代码]这套接口的代码,就是检查其参数是否合法,如果参数有问题就返回相关的错误,接着调用下层完成功能的核心代码</p></blockquote><h6 id="内核功能层"><a href="#内核功能层" class="headerlink" title="内核功能层"></a>内核功能层</h6><blockquote><p>主要完成各种实际功能,这些功能按照其类别可以分成各种模块,当然这些功能模块最终会用具体的算法、数据结构、代码去实现它<br>[进程管理] 主要是实现进程的创建、销毀、调度进程,当然这要设计几套数据结构用于<strong>表示进程和组织进程</strong>,还要实现一个简单的<strong>进程调度算法</strong></p><p>[内存管理] 在内核功能层中只有<strong>内存池管理</strong>,分两种内存池:页面内存池和任意大小的内存池</p><p>[中断管理] 这个在内核功能层中非常简单:就是把一个中断回调函数安插到相关的数据结构中,一旦发生相关的中断就会调用这个函数</p><p>[设备管理]这个是最难的,需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备,最后把它们组织在一起,还要实现创建设备、销毀设备、访问 设备的代码,这些代码最终会调用设备驱动程序,达到操作设备的目的</p></blockquote><h6 id="内核硬件层"><a href="#内核硬件层" class="headerlink" title="内核硬件层"></a>内核硬件层</h6><blockquote><p>[初始化] 初始化代码是<strong>内核被加载到内存</strong>中最先需要运行的代码,例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构等</p><p>[CPU控制] 提供CPU模式设定、开、关中断、读写CPU特定寄存器等功能的代码</p><p>[中断处理] 保存中断时机器的上下文,调用中断回调函数,操作中断控制器等</p><p>[物理内存管理] 提供分配、释放大块内存,内存空间映射,操作MMU、 Cache等</p><p>[平台其它相关的功能] 有些硬件平台上有些特殊的功能,需要额外处理</p></blockquote><p><img src="/img/OS-3/3-2.jpg" alt="3-2"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><blockquote><p>混合内核( hybrid kernel)</p><p>我们的操作系统内核没有任何设备驱动程序,甚至没有文 件系统和网络组件,内核所实现的功能很少。</p><p>这吸取了微内核的优势,内核小出问题的可 能性就少,扩展性就越强。同时,我们把文件系统、网络组件、其它功能组件作为虚拟设备交由设备管理,比如需要文件系统时就写一个文件系统虚拟设备的驱动,完成文件系统的功能,需要网络时就开发个网络虚拟设备的驱动,完成网络功能。<br>这些<strong>驱动一旦被装载,就是内核的一部分</strong>,并不是像微内核一样作为服务进程运行。这又吸取了宏内核的优势,代码高度耦合,性能强劲<br>这样的内核架构既不是宏内核架构也不是微内核架构,而是这两种架构综合的结果</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;br&gt;&lt;em&gt;开发操作系统内核就像建房子 样,房子要建得好,就先要设计。比如用什么结构,什么材料,房间怎么布局,电路 水路等,最后画出设计图纸,依据图纸按部就班地进行建造&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>始-Hello OS</title>
    <link href="http://example.com/2021/10/03/[OS]Hello/"/>
    <id>http://example.com/2021/10/03/[OS]Hello/</id>
    <published>2021-10-03T09:00:00.000Z</published>
    <updated>2021-10-03T12:42:19.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p><em>写操作系统要用汇编和C语言,现有的商业操作系统都是用这两种语言开发出来的</em></p><h5 id="PC机的引导流程"><a href="#PC机的引导流程" class="headerlink" title="PC机的引导流程"></a>PC机的引导流程</h5><blockquote><p>借用一下 GRUB 引导程序</p><p>只要我们的 PC 机上安装了 Ubuntu Linux 操作系统，GRUB 就已经存在</p><p><img src="/img/OS-2/2-1.png" alt="2-1"></p><p>OS 引导流程</p><p><img src="/img/OS-2/2-2.jpg" alt="2-2"></p><ul><li>PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的（掉电也能保存）</li></ul><blockquote><p>ROM是只读内存（Read-Only Memory）此内存的制造成本较低，常用于电脑中的开机启动</p></blockquote><ul><li>PC 机上电后的<strong>第一条指令</strong>就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区<strong>数据</strong>，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处<strong>执行指令</strong>，在我们这里的情况下就是 GRUB 引导程序</li></ul></blockquote><h5 id="OS引导汇编"><a href="#OS引导汇编" class="headerlink" title="OS引导汇编"></a>OS引导汇编</h5><blockquote><ul><li>为什么不能直接用 C？</li></ul><p>C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要<strong>用栈</strong>（栈由 CPU 特定的<strong>栈寄存器指向</strong>，所以我们要先用汇编代码处理好这些 C 语言的工作环境）</p><p><strong>[entry.asm]</strong></p><blockquote><ol><li>代码 1~40 行，用汇编定义的 GRUB 的多引导协议头，其实就是一定格式的数据，我们的 Hello OS 是用 GRUB 引导的，当然要遵循 GRUB 的多引导协议标准，<strong>让 GRUB 能识别我们的 Hello OS</strong>  之所以有两个引导头，是为了兼容 GRUB1 和 GRUB2。</li><li>代码 44~52 行，<strong>关掉中断，设定 CPU 的工作模式</strong>。你现在可能不懂，没事儿，后面 CPU 相关的课程我们会专门再研究它。</li><li>代码 54~73 行，<strong>初始化 CPU 的寄存器和 C 语言的运行环境</strong>。</li><li>代码 78~87 行，GDT_START 开始的，是 <strong>CPU 工作模式所需要的数据</strong>，同样，后面讲 CPU 时会专门介绍。</li></ol></blockquote></blockquote><h5 id="OS主函数"><a href="#OS主函数" class="headerlink" title="OS主函数"></a>OS主函数</h5><blockquote><p><strong>[main.c]</strong></p><p>汇编代码调用了 main 函数，用 C 语言写的在main.c中，最终它们分别由 nasm 和 GCC 编译成<strong>可链接模块</strong>，由 <strong>LD 链接器</strong>链接在一起，形成可执行的程序文件<br>#include “vgastr.h”<br>void main()<br>{<br>printf(“Hello OS!”);<br>return;<br>} //printf 也不是应用程序库中的那个 printf 了，而是需要我们自己实现</p></blockquote><h5 id="屏幕显示"><a href="#屏幕显示" class="headerlink" title="屏幕显示"></a>屏幕显示</h5><blockquote><p>计算机屏幕显示往往是显卡的输出，显卡有很多形式：集成在主板的叫<strong>集显</strong>，做在 CPU 芯片内的叫<strong>核显</strong>，独立存在通过 PCIE 接口连接的叫<strong>独显</strong>，性能依次上升，价格也是</p><p>要在屏幕上显示字符，就要<strong>编程操作显卡</strong></p><p>无论什么显卡都支持一种叫 VESA 的标准，这种标准下有两种工作模式：字符模式和图形模式。显卡们为了兼容这种标准，不得不自己提供一种叫 <strong>VGABIOS 的固件程序</strong></p><ul><li>显卡的<strong>字符模式</strong></li></ul><p>它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 0xb8000 地址开始的内存中，每<strong>两个字节</strong>对应一个字符，其中一个字节是字符的 <strong>ASCII 码</strong>，另一个字节为字符的<strong>颜色值</strong></p><p><img src="/img/OS-2/2-3.jpg" alt="2-3"></p><p><em>C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的</em></p><p><strong>[vgastr.c]</strong></p><p>代码很简单, printf I函数直接调用了 strwrite图数,而_ strwrite函数正是将字符串 里每个字符依次定入到0Xxb8000地址开始的显存中,而p_ strdst每次加2,这也是为 了跳过字符的颜色信息的空间</p></blockquote><h5 id="编译–Hello-OS-bin"><a href="#编译–Hello-OS-bin" class="headerlink" title="编译–Hello OS.bin"></a>编译–Hello OS.bin</h5><blockquote><p>安装之前我们要进行系统编译（代码块编译最终链接成可执行的二进制文件）</p><ul><li>make </li></ul><p>make 是一个工具程序，它读取一个叫“Makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件</p><p><strong>[Makefile]</strong></p><p>makefile文件中规则是这样的:首先有一个或者多个构建目标称为“ target”;目标后面 紧跟着用于构建该目标所需要的文件,目标下面是构建该目标所需要的命令及参数</p><p>第一次构建目标后,下ー次执行make时,它会根据该目标所依赖的文件是否更新決定 是否编译该目标,如果所依赖的文件没有更新且该目标又存在,那么它便不会构建该目 示。这种特性非常有利于编译程序源代码</p><p><img src="/img/OS-2/2-4.jpg" alt="2-4"></p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><blockquote><p>需要GRUB在启动时找到Hello OS.bin，计算机才能在启动时加载它</p><ul><li>修改启动项</li></ul><p>经研究发现,GRUB在启动时会加载一个grub.cfg的文本文件,根据其中的内容执行 相应的操作,其中一部分内容就是启动项<br>GRUB首先会显示启动项到屏幕,然后让我们选择启动项,最后GRUB根据启动项对应的信息,加载OS文件到内存</p><p>[Hello OS的启动项]</p><p>menuentry ‘Helloos’ {<br>    insmod part_ msdos #GRUB加载分区模块识别分区<br>    insmod ext2  #GRUB加载ext文件系统模块识别ext文件系统<br>    set root=’hdo, msdos4’ #注意boot目录挂载的分区</p><p>​    multi boot2/boot/ Hellos.bin #GRUB以 multi boot2协议加载 Hellos.bin       boot #GRUB启动 Hellos.bin</p><p>}</p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4</p></blockquote><p><em>启动项放入/boot/grub/grub.cfg中</em></p><p><em>Hello OS.bin复制到/boot/</em></p></blockquote><h5 id="Do-——"><a href="#Do-——" class="headerlink" title="[Do]——"></a>[Do]——</h5><p><em>环境：Vmware Fusion—ubuntu18.04 虚拟机</em></p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><blockquote><p>$ sudo apt-get install  nasm</p><p>$ sudo apt-get install  make</p></blockquote><p>在Hello OS文件夹下执行</p><p>$ make -f Makefile |$ make all </p><p>—-&gt; HelloOS.bin</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><blockquote><ul><li>cp</li></ul><p>$ cp  HelloOS.bin /boot</p><p><img src="/img/OS-2/2-5.png" alt="2-5"></p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4<br><img src="/img/OS-2/2-6.png" alt="2-6"></p></blockquote><ul><li><p>启动项 /boot/grub/grub.cfg<br>$ sudo update-grub<br><img src="/img/OS-2/2-7.png" alt="2-7"></p></li><li><p>启动<br><img src="/img/OS-2/2-8.png" alt="2-8"><br><img src="/img/OS-2/2-9.png" alt="2-9"></p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;写操作系统要用汇编和C语言,现有的商业操作系统都是用这两种语言开发出来的&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&quot;PC机的引导流程&quot;&gt;&lt;a href=&quot;#PC机的引导流程&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>始-程序运行</title>
    <link href="http://example.com/2021/10/03/[OS]%E5%A7%8B/"/>
    <id>http://example.com/2021/10/03/[OS]%E5%A7%8B/</id>
    <published>2021-10-03T02:00:00.000Z</published>
    <updated>2021-10-03T07:36:16.328Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><blockquote><p> [1] Ken Thompson （one month）创造Unix</p><p> 又与[2]Dennis Ritchie 共同创造C语言</p></blockquote><blockquote><p>计算机<strong>硬件</strong>是无法直接运行这个 C 语言<strong>文本程序</strong>代码的</p><ul><li><p>需要 C 语言【编译器】，把这个代码编译成<strong>具体硬件平台</strong>的[二进制代码]</p></li><li><p>再由具体【操作系统】建立进程，把这个二进制文件装进其进程的<strong>内存空间</strong>中</p></li></ul><h5 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h5><blockquote><p>GCC 相关的工具链</p><p>$ gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld</p><p>GCC 只是完成编译工作的<strong>动程序</strong>，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作</p><p><img src="/img/OS-1/1-1.jpg" alt="1-1"></p><p>gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入<strong>头文件</strong>，替换<strong>宏</strong>。</p><p>gcc HelloWorld.c -S -c HelloWorld.s 编译：包含预处理，将 C 程序转换成<strong>汇编程序</strong>。</p><p>gcc HelloWorld.c -c HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成<strong>可链接的二进制程序</strong>。</p><hr><p>gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将<strong>可链接的二进制程序和其它别的库链接</strong>在一起，形成可执行的程序文件。</p></blockquote></blockquote><blockquote><p> [3] 阿兰图灵的图灵机</p><p> 图灵机是一个抽象的模型,它是这样的:有一条无限长的纸带,纸带上有无限个小格 子,小格子中写有相关的信息,纸带上有一个读头,<strong>读头能根据纸带小格子里的信息做 相关的操作并能来回移动</strong></p><p> [4] 冯诺伊曼的体系结构</p><p> 电子计算机使用<strong>二进制数制系统</strong>和<strong>储存程序</strong>,并按照程序顺序执行</p><ul><li>把程序和数据装入到计算机中;</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果;</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理;</li><li>根据需要控制程序走向,并能根据指令控制机器的各部件协调操作;</li><li> 能够按照要求将处理的数据结果显示给用户。</li></ul><p> 为了完成上述的功能,计算机必须具备五大基本组成部件</p><ul><li>装载数据和程序的输入设备</li><li>记住程序和数据的存储器</li><li>完成数据加工处理的运算器</li><li>控制程序执行的控制器</li><li>显示处理结果的输出设备</li></ul><p> Finally</p><blockquote><p><img src="/img/OS-1/1-2.jpg" alt="1-2"></p><p>我们发现读头不再来回移动了，而是靠<strong>地址总线</strong>寻找对应的“纸带格子”。读取写入数据由<strong>数据总线</strong>完成，而动作的控制就是<strong>控制总线</strong>的职责了</p></blockquote></blockquote><blockquote><h5 id="装载执行"><a href="#装载执行" class="headerlink" title="装载执行"></a>装载执行</h5><blockquote><ul><li>反汇编</li></ul><p>gcc -c -S HelloWorld</p><p><img src="/img/OS-1/1-3.jpg" alt="1-3"></p><p>第一列为地址；第二列为十六进制，表示<strong>真正装入机器中的代码数据</strong>；第三列是对应的<strong>汇编代码</strong>；第四列是相关<strong>代码的注释</strong>。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集</p><p><img src="/img/OS-1/1-4.jpg" alt="1-4"></p><p>现代电子计算机正是通过内存中的信息（<strong>指令和数据</strong>）做出相应的<strong>操作</strong>，并通过<strong>内存地址</strong>的变化，达到程序<strong>读取数据，控制程序流程</strong>（顺序、跳转对应该图灵机的读头来回移动）的功能</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; [1] Ken Thompson （one month）创造Unix&lt;/p&gt;
&lt;p&gt; 又与[2]Dennis Ritchie 共同创造C语言&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>筑-空中楼阁</title>
    <link href="http://example.com/2021/09/27/%E7%AD%91/"/>
    <id>http://example.com/2021/09/27/%E7%AD%91/</id>
    <published>2021-09-27T02:00:00.000Z</published>
    <updated>2021-09-27T06:44:19.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p><em>物理资源的逻辑抽象</em></p><p><em>从底层向应用层</em></p><blockquote><p>计算机是可以自动执行任意的逻辑或算数指令序列的机器</p><p>计算机 = 一台自动执行的机器 + <strong>一张说明书（程序）</strong>+ 一张白纸（存</p><p>储）</p><h4 id="一张说明书"><a href="#一张说明书" class="headerlink" title="一张说明书"></a>一张说明书</h4><ul><li>程序(说明书)</li></ul><blockquote><p>程序 = 算法 + 数据结构</p><p>程序是用来指导计算机应该做些什么事情的一张<strong>说明书</strong>，只有在程序的</p><p>帮助下，计算机才知道应该如何执行</p><p><strong>程序的最终目的是用来处理数据的</strong>。</p><p>一个程序可能没有输入，但是一定会有输出。不然就是浪费电</p></blockquote><ul><li>算法</li></ul><blockquote><p>算法是程序的逻辑</p></blockquote><ul><li>数据结构</li></ul><blockquote><p>数据结构是计算机中存储、组织数据的方式，让计算机高效的处理数据</p></blockquote><ul><li>语言</li></ul><blockquote><p>语言是程序的表示方法</p></blockquote><h4 id="一台机器"><a href="#一台机器" class="headerlink" title="一台机器"></a>一台机器</h4><ul><li>CPU</li></ul><blockquote><ol><li><p>知道程序（说明书）存储的位置</p></li><li><p>知道自己运行到说明书的什么地方</p></li><li><p>可以读取直接自己下一条应该根据（程序）说明书干什么事情</p></li><li><p>能干的事情：算数逻辑运算，或者跳转（说明书分支）</p></li></ol></blockquote><h4 id="一张白纸"><a href="#一张白纸" class="headerlink" title="一张白纸"></a>一张白纸</h4><ul><li>CPU 的寄存器 (Register)</li></ul><blockquote><p>CPU 本身有数据的缓存地方，叫做寄存器</p><p>数据只有在寄存器里面，才可以被 CPU 进行运算（易失）</p><p>读取寄存器的延迟时间：1</p><p>寄存器的大小：几十个数字</p></blockquote><ul><li>高速缓存 (Cache)</li></ul><blockquote><p>高速缓存是 CPU 的一个部分（不同于寄存器），由硬件进行管理，可以</p><p>忽略看不见（易失)</p><p>读取高速缓存的延迟时间：10-50</p><p>高速缓存的大小：10M 左右</p></blockquote><ul><li><p>主存 (内存，Main memory)</p><blockquote><p>主存是最大的 CPU 可以<strong>直接调用</strong>的最大的存储设备</p><p>所有的程序和数据运行的时候都会缓存在主存里面(易失)</p><p>读取主存的延迟时间：100+</p><p>主存的大小：1G-100G</p></blockquote></li><li><p>硬盘 (Hard disk)</p><blockquote><p>最大的存储设备(非易失)</p><p>读取硬盘的延迟时间：1000+</p><p>硬盘的大小：100G-1T</p></blockquote></li></ul></blockquote><p><em>一穷二白的年纪 至少还有微薄的工资｜充足的时间｜免费的网络资源｜可以记录生活的设备</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;物理资源的逻辑抽象&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从底层向应用层&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机是可以自动执行任意的逻辑或算数指令序列的机器&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="yan" scheme="http://example.com/tags/yan/"/>
    
  </entry>
  
  <entry>
    <title>研途</title>
    <link href="http://example.com/2021/09/16/%E7%A0%94%E9%80%94/"/>
    <id>http://example.com/2021/09/16/%E7%A0%94%E9%80%94/</id>
    <published>2021-09-16T02:00:00.000Z</published>
    <updated>2021-09-16T02:35:09.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p>还有<strong>197</strong>天<br><br>以一个计算机专业的身份毕业<br></p><br><br><br>  *一穷二白的年纪 至少还有微薄的工资｜充足的时间｜免费的网络资源｜可以记录生活的设备*]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/yan.jpg&quot; alt=&quot;yan&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有&lt;strong&gt;197&lt;/strong&gt;天&lt;br&gt;&lt;br&gt;以一个计算机专业的身份毕业&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
  
*一穷二白的年纪 至少还有微薄的工资｜充足的时间</summary>
      
    
    
    
    
    <category term="yan" scheme="http://example.com/tags/yan/"/>
    
  </entry>
  
</feed>
