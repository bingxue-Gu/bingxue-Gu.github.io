<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Net-网络协议</title>
      <link href="2021/10/12/%5BNet%5D001/"/>
      <url>2021/10/12/%5BNet%5D001/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><h5 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h5><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><h5 id="IP分配"><a href="#IP分配" class="headerlink" title="IP分配"></a>IP分配</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-data structure</title>
      <link href="2021/10/09/%5BAlg%5D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/10/09/%5BAlg%5D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><h5 id="你猜"><a href="#你猜" class="headerlink" title="你猜"></a>你猜</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Alg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计-内核分层</title>
      <link href="2021/10/03/%5BOS%5D%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/10/03/%5BOS%5D%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><h5 id="「-操作系统内核设计-」"><a href="#「-操作系统内核设计-」" class="headerlink" title="「 操作系统内核设计 」"></a>「 操作系统内核设计 」</h5><p><em>开发操作系统内核就像建房子一样,房子要建得好,就先要设计。比如用什么结构,什么材料,房间怎么布局,电路 水路等,最后画出设计图纸,依据图纸按部就班地进行建造</em></p><h5 id="计算机资源"><a href="#计算机资源" class="headerlink" title="计算机资源"></a>计算机资源</h5><blockquote><p>从抽象角度来看,内核就是 [<strong>计算机资源的管理者</strong>] ,当然管理资源是为了 [<strong>让应用使用资源</strong>]</p><ul><li>硬件资源</li></ul><p>1.总线,负责连接各种其它设备,是其它设备工作的基础。<br>2.CPU,即中央处理器,负责执行程序和处理数据运算。<br>3.内存,负责储存运行时的代码和数据。<br>4.硬盘,负责长久储存用户文件数据。<br>5.网卡,负责计算机与计算机之间的通信。<br>6.显卡,负责显示工作。<br>7.各种IO设备,如显示器,打印机,键盘,鼠标等。</p><p><img src="/img/OS-3/3-1.jpg" alt="3-1"></p><ul><li>软件资源</li></ul><p>而计算机中的软件资源,则可表示为计算机中的各种形式的[数据]如各种文件、软件程序等</p></blockquote><h5 id="内核组件（管理资源）"><a href="#内核组件（管理资源）" class="headerlink" title="内核组件（管理资源）"></a>内核组件（管理资源）</h5><blockquote><ul><li>管理CPU, 由于CPU是执行程序的,而内核把运行时的程序抽象成进程,所以又称为 [<strong>进程管理</strong>]</li><li>管理内存,由于程序和数据都要占用内存,内存是非常宝贵的资源,所以内核要非常小 心地分配、释放内存</li><li>管理硬盘,而硬盘主要存放用户数据,而内核把用户数据抽象成文件,即管理文件,文件需要合理地组织,方便用户查找和读写,所以形成了 <strong>[文件系统]</strong></li><li>管理显卡,负责显示信息,而现在操作系统都是支持GU(图形用户接口)的,管理显卡自然而然地就成了内核中的图形系统</li><li>管理网卡,网卡主要完成网络通信,网络通信需要各种通信协议,最后在内核中就形成了 <strong>[网络协议栈]</strong>,又称网络组件</li><li>管理各种I/O设备,我们经常把键盘、鼠标、打印机、显示器等统称为IO(输入输出)设备,在内核中抽象成IO管理器</li></ul><p>(内核除了这些必要组件之外,根据功能不同还有安全组件等,最值得一提的是,各种计算机硬件的性能不同,硬件型号不同,硬件种类不同,硬件厂商不同,内核要想管理和控制 这些硬件就要编写对应的代码,通常这样的代码我们称之为[<strong>驱动程序</strong>] )</p></blockquote><h5 id="经典的内核结构（组件组织方式）"><a href="#经典的内核结构（组件组织方式）" class="headerlink" title="经典的内核结构（组件组织方式）"></a>经典的内核结构（组件组织方式）</h5><blockquote><h6 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h6><blockquote><p>宏内核就是把以上诸如管理进程的代码、管理内存的代码、管理各种/O设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码,把这些所有的代码经过编译,最 后链接在一起,形成一个”大的可执行程序”</p><ul><li>API </li></ul><p>这个大程序里有实现支持这些功能的所有代码,向用户应用软件提供一些接口,这些接口就是常说的系统API函数。</p><ul><li>特权模式</li></ul><p>而这个大程序会在处理器的特权模式下运行,这个模式通常被称为**宏内核模式</p><hr><p>[服务过程-简]</p><p>1.应用程序调用内存分配的API(应用程序接口)函数<br>2.处理器切换到<strong>特权模式</strong>,开始运行内核代码<br>3.内核里的<strong>内存管理</strong>代码按照特定的算法,分配一块内存<br>4.把分配的内存块的首地址,返回给内存分配的API函数<br>5.内存分配的API函数返回,处理器开始运行<strong>用户模式</strong>下的应用程序,应用程序就得到了一块内存的首地址,并且可以使用这块内存了</p><p>性能好｜ 可拓展性差</p></blockquote><h6 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h6><blockquote><p>微内核架构正好与宏内核架构相反,它提倡内核功能尽可能少:仅仅只有进程调度、处理中断、内存空间映射、进程间通信等功能</p><ul><li>服务进程</li></ul><p>开发者们把实际的进程管理、内存管理、设备管 理、文件管理等服务功能,做成一个个服务进程。和用户应用进程一样,只是它们很特殊,宏内核提供的功能,在微内核架构里由这些服务进程专门负责完成</p><ul><li>消息机制</li></ul><p>微内核定义了一种良好的进程间通信的机制——消息</p><p>应用程序要请求相关服务,就向微 内核发送一条与此服务对应的消息,<strong>微内核再把这条消息转发给相关的服务进程</strong>,接着服务进程会完成相关的服务</p><p>服务进程的编程模型就是循环处理来自其它进程的消息,完成相关的服务功能</p><hr><p>[服务过程-简]</p><p>1.应用程序发送<strong>内存分配的消息</strong>,这个发送消息的函数是微内核提供的,相当于系统API,微内核的API(应用程序接口)相当少,极端情況下仅需要两个,一个接收消息的API和一个发送消息的API<br>2.处理器切换到<strong>特权模式</strong>,开始运行内核代码。<br>3.微内核代码让当前进程停止运行,并根据消息包中的数据,确定消息发送给谁,分配内存的消息当然是发送给内存管理服务进程<br>4.内存管理服务进程收到<strong>消息</strong>,分配一块内存<br>5.内存管理服务进程,也会通过消息的形式返回分配内存块的地址给内核,然后继续等待下一条<strong>消息</strong><br>6.微内核把包含内存块地址的<strong>消息</strong>返回给发送内存分配消息的应用程序<br>7.处理器开始运行<strong>用户模式</strong>下的应用程序,应用程序就得到了一块内存的首地址,并且可 以使用这块内存了</p><p>性能差｜ 可拓展性好</p></blockquote></blockquote><h5 id="分离硬件相关性"><a href="#分离硬件相关性" class="headerlink" title="分离硬件相关性"></a>分离硬件相关性</h5><blockquote><p>庞杂的计算机,其实也是一层一层地构建起来的,从硬件层到操作系统层再到应用软件层这样构建</p><p><em>分层的主要目的和好处在于屏蔽底层细节,使上层开发更加简单</em></p><ul><li>分离硬件的相关性</li></ul><blockquote><p>把<strong>操作硬件和处理硬件</strong>功能差异的代码抽离出来,形成一个独立的软件抽象层,对外提供相应的接口,方便上层开发</p></blockquote><ul><li>进程（例子）</li></ul><blockquote><p><em>一般操作系统理论课程都会花大量篇幅去讲进程相关的概念,其实说到底,<strong>进程是操作系统开发者为了实现多任务而提出的</strong>,并让每个进程在CPU上运行一小段时间,这样就能实现多任务同时运行的假象</em></p><ul><li>两种机制</li></ul><blockquote><p>[进程调度] 它的目的是要从众多进程中选择一个将要运行的进程,当然有各种选择的算法,例如,轮转算法、优先级算法等<br>[进程切换] 它的目的是停止当前进程,运行新的进程,主要动作是保存当前进程的机器上下文,装载新进程的机器上下文</p></blockquote><p>不管是在ARM硬件平台上还是在x86硬件平台上,选择一个进程的算法和代码是不容易发生改变的,需要改变的代码是<strong>进程切换的相关代码</strong>,因为不同的硬件平台的机器上下文是不同的</p></blockquote><ul><li>硬件平台相关层</li></ul><blockquote><p>如果把所有硬件平台相关的代码,都抽离出来,放在一个独立硬件相关层中实现并且定义好相关的<strong>调用接口</strong>,再在这个层之上开发内核的其它功能代码,就会方便得多,结构也会清晰很多。操作系统的<strong>移植性</strong>也会大大增强,移植到不同的硬件平台时,就构造开发一个 与之对应的硬件相关层</p></blockquote></blockquote><h5 id="自主设计"><a href="#自主设计" class="headerlink" title="自主设计"></a>自主设计</h5><blockquote><h6 id="内核接口层"><a href="#内核接口层" class="headerlink" title="内核接口层"></a>内核接口层</h6><blockquote><p>内核接口层,定义了一系列接口,主要有两点内容,如下<br>[UINX接口的子集]出于学习和研究的目的,使用UNX接口的子集,优点之一是接口少,只有几个,并且这几个接口又能大致定义出操作系统的功能<br>[代码]这套接口的代码,就是检查其参数是否合法,如果参数有问题就返回相关的错误,接着调用下层完成功能的核心代码</p></blockquote><h6 id="内核功能层"><a href="#内核功能层" class="headerlink" title="内核功能层"></a>内核功能层</h6><blockquote><p>主要完成各种实际功能,这些功能按照其类别可以分成各种模块,当然这些功能模块最终会用具体的算法、数据结构、代码去实现它<br>[进程管理] 主要是实现进程的创建、销毀、调度进程,当然这要设计几套数据结构用于<strong>表示进程和组织进程</strong>,还要实现一个简单的<strong>进程调度算法</strong></p><p>[内存管理] 在内核功能层中只有<strong>内存池管理</strong>,分两种内存池:页面内存池和任意大小的内存池</p><p>[中断管理] 这个在内核功能层中非常简单:就是把一个中断回调函数安插到相关的数据结构中,一旦发生相关的中断就会调用这个函数</p><p>[设备管理]这个是最难的,需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备,最后把它们组织在一起,还要实现创建设备、销毀设备、访问 设备的代码,这些代码最终会调用设备驱动程序,达到操作设备的目的</p></blockquote><h6 id="内核硬件层"><a href="#内核硬件层" class="headerlink" title="内核硬件层"></a>内核硬件层</h6><blockquote><p>[初始化] 初始化代码是<strong>内核被加载到内存</strong>中最先需要运行的代码,例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构等</p><p>[CPU控制] 提供CPU模式设定、开、关中断、读写CPU特定寄存器等功能的代码</p><p>[中断处理] 保存中断时机器的上下文,调用中断回调函数,操作中断控制器等</p><p>[物理内存管理] 提供分配、释放大块内存,内存空间映射,操作MMU、 Cache等</p><p>[平台其它相关的功能] 有些硬件平台上有些特殊的功能,需要额外处理</p></blockquote><p><img src="/img/OS-3/3-2.jpg" alt="3-2"></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><blockquote><p>混合内核( hybrid kernel)</p><p>我们的操作系统内核没有任何设备驱动程序,甚至没有文 件系统和网络组件,内核所实现的功能很少。</p><p>这吸取了微内核的优势,内核小出问题的可 能性就少,扩展性就越强。同时,我们把文件系统、网络组件、其它功能组件作为虚拟设备交由设备管理,比如需要文件系统时就写一个文件系统虚拟设备的驱动,完成文件系统的功能,需要网络时就开发个网络虚拟设备的驱动,完成网络功能。<br>这些<strong>驱动一旦被装载,就是内核的一部分</strong>,并不是像微内核一样作为服务进程运行。这又吸取了宏内核的优势,代码高度耦合,性能强劲<br>这样的内核架构既不是宏内核架构也不是微内核架构,而是这两种架构综合的结果</p></blockquote></blockquote><h5 id="「-业界成熟OS设计-」"><a href="#「-业界成熟OS设计-」" class="headerlink" title="「 业界成熟OS设计 」"></a>「 业界成熟OS设计 」</h5><p>“<em>假如你是一个汽车工程师，或者还在学习造汽车的技术，那如果业界有这么一款汽车，性能稳定，设计思想优秀，而且不断在改进，汽车内部一些模块的实现方式甚至成为了业界标准，不仅如此，这款汽车的内部所有详细的技术资料都可以免费获取，也正因为如此，市面上也萌生了超级多的 Linux 发动机构造详解，深入理解 Linux 悬挂系统，你觉得你需不需要学习这款汽车？”</em></p><h5 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h5><blockquote><p>Linux,全称GNU/ Linux,是一套<strong>免费使用和自由传播</strong>的操作系统,支持类UNIX、POSX标准接口,也支持多用户、多进程、多线程,可以在多CPU的机器上运行</p><h6 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h6><blockquote><p>每个文件都有确定的用途,包括用户数据、命令配置参数、硬件设备等</p><p>对于操作系统内核而言,都被视为<strong>各种类型的文件</strong></p><p>Linux支持<strong>多用户</strong>,各个用户对于自己的文件有自己特殊的权利,保证了各用户之间互不影响。多任务则是现代操作系统最重要的一个特点, Linux可以使多个程序同时并独立地运行</p></blockquote><p>内部结构</p><p><img src="/img/OS-3/4-0.png" alt="4-0"></p><p>重要组件</p><p><img src="/img/OS-3/4-1.jpg" alt="4-1"></p><ul><li>宏内核</li></ul><p> Linux多模块挤在一起,之间的通信主要是<strong>函数调用</strong>,而且函数间的调用没有一定的层次关系,更加没有左右边界的限定</p></blockquote><h5 id="Darwin-XNU内核"><a href="#Darwin-XNU内核" class="headerlink" title="Darwin-XNU内核"></a>Darwin-XNU内核</h5><blockquote><p>Darwin是由苹果公司在2000年开发的一个开放源代码的操作系统</p><p>Darwin使用了一种微内核(Mach)和相应的固件来支持不同的处理器平台(Powerpc、x86、ARM架构的处理器),并提供操作系统原始的基础服务,上层的功能性系统服务和工具则是整合了BSD系统所提供的。苹果公司还为其开发了大量的库、框架和服务,不过它们都工作在用户态且闭源</p><p><img src="/img/OS-3/4-2.jpg" alt="4-2"></p><h6 id="Mach-amp-BSD"><a href="#Mach-amp-BSD" class="headerlink" title="Mach &amp; BSD"></a>Mach &amp; BSD</h6><blockquote><p>Mach内核是卡耐基梅隆大学开发的经典微内核,意在提供最基本的操作系统服务,从而达到高性能、安全、可扩展的目的,而BSD则是伯克利大学开发的类UNX操作系统,提供一整套操作系统服务</p><p>Mach内核仍然提供十分简单的<strong>进程、线程、IPC通信、虚拟内存设备驱动相关的功能服务</strong>,BSD则提供强大的<strong>安全特性,完善的网络服务,各种文件系统的支持</strong>,同时对Mach的进程、线程、IPC、虚拟内核组件进行细化、扩展延伸</p><p>[Why]</p><p>MAC OS X(2011年之前的称呼)的发展经过了不同时期,随着时代的进步,产品功能需求增加,单纯的Mach之上实现出现了性能瓶颈,但是为了兼容之前为Mach开 发的应用和设备驱动,就保留了Mach内核,同时加入了BSD内核</p><p>[How]</p><p>在调用 Darwin系统API时,会传入ー个API号码,用这个号码去索引Mach陷入中 断服务表中的函数</p><p>API号码如果小于0,则表明请求的是Mach内核的服务,<br>API号码如果大于0,则表明请求的是BSD内核的服务,它提供一整套标准的 POSIX接口</p><p>[*Libkern]</p><p>Mach中还有一个重要的组件 Libkern,它是一个库,提供了很多底层的操作函数,同时支持C++运行环境<br>依赖这个库的还有<strong>IOKit</strong>,IOKit管理所有的设备驱动和内核功能扩展模块。驱动程序开发人员则可以使用C++面向对象的方式开发驱动,这个方式很优雅,你完全可以找成熟的驱动程序作为父类继承它,要特别实现某个功能就重载其中的函数,也可以同时继承其它驱动程序,这大大节省了内存,也大大降低了出现BUG的可能</p></blockquote></blockquote><h5 id="Windows-NT内核"><a href="#Windows-NT内核" class="headerlink" title="Windows NT内核"></a>Windows NT内核</h5><blockquote><p>Windows NT是微软于1993年推出的面向工作站、网络服务器和大型计算机的网络操作系统,也可做PC操作系统。它是一款全新人零开始开发的新操作系统,并应用了现代硬件的所有特性,“NT”所指的便是“新技术”( New Technology)</p><p><img src="/img/OS-3/4-3.jpg" alt="4-3"></p><h6 id="小内核"><a href="#小内核" class="headerlink" title="小内核"></a>小内核</h6><blockquote><p>[小内核之下] 是硬件抽象层HAL(不同的硬件平台只要提供对应的HAL就可以移植系統了)</p><p>[小内核之上] 是各种内核组件,微软称之为<strong>内核执行体</strong>,它们完成<strong>进程、内存、配置、I/O文件、缓存、电源与即插即用、安全</strong>等相关的服务<br>每个执行体互相独立,只对外提供相应的接口,其它执行体要通过内核模式可调用接口和其它执行体通信或者请求其完成相应的功能服务。所有的设备驱动和文件系统都由I/O管理器统一管理,驱动程序可以堆叠形成I/O驱动栈,功能请求被封装成I/O包在栈中一层层流动处理。 Windows引以为做的图形子系统也在内核中。</p></blockquote></blockquote><p><em>参考《操作系统实战45讲》</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始-Hello OS</title>
      <link href="2021/10/03/%5BOS%5DHello/"/>
      <url>2021/10/03/%5BOS%5DHello/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p><em>写操作系统要用汇编和C语言,现有的商业操作系统都是用这两种语言开发出来的</em></p><h5 id="PC机的引导流程"><a href="#PC机的引导流程" class="headerlink" title="PC机的引导流程"></a>PC机的引导流程</h5><blockquote><p>借用一下 GRUB 引导程序</p><p>只要我们的 PC 机上安装了 Ubuntu Linux 操作系统，GRUB 就已经存在</p><p><img src="/img/OS-2/2-1.png" alt="2-1"></p><p>OS 引导流程</p><p><img src="/img/OS-2/2-2.jpg" alt="2-2"></p><ul><li>PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的（掉电也能保存）</li></ul><blockquote><p>ROM是只读内存（Read-Only Memory）此内存的制造成本较低，常用于电脑中的开机启动</p></blockquote><ul><li>PC 机上电后的<strong>第一条指令</strong>就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区<strong>数据</strong>，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处<strong>执行指令</strong>，在我们这里的情况下就是 GRUB 引导程序</li></ul></blockquote><h5 id="OS引导汇编"><a href="#OS引导汇编" class="headerlink" title="OS引导汇编"></a>OS引导汇编</h5><blockquote><ul><li>为什么不能直接用 C？</li></ul><p>C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要<strong>用栈</strong>（栈由 CPU 特定的<strong>栈寄存器指向</strong>，所以我们要先用汇编代码处理好这些 C 语言的工作环境）</p><p><strong>[entry.asm]</strong></p><blockquote><ol><li>代码 1~40 行，用汇编定义的 GRUB 的多引导协议头，其实就是一定格式的数据，我们的 Hello OS 是用 GRUB 引导的，当然要遵循 GRUB 的多引导协议标准，<strong>让 GRUB 能识别我们的 Hello OS</strong>  之所以有两个引导头，是为了兼容 GRUB1 和 GRUB2。</li><li>代码 44~52 行，<strong>关掉中断，设定 CPU 的工作模式</strong>。你现在可能不懂，没事儿，后面 CPU 相关的课程我们会专门再研究它。</li><li>代码 54~73 行，<strong>初始化 CPU 的寄存器和 C 语言的运行环境</strong>。</li><li>代码 78~87 行，GDT_START 开始的，是 <strong>CPU 工作模式所需要的数据</strong>，同样，后面讲 CPU 时会专门介绍。</li></ol></blockquote></blockquote><h5 id="OS主函数"><a href="#OS主函数" class="headerlink" title="OS主函数"></a>OS主函数</h5><blockquote><p><strong>[main.c]</strong></p><p>汇编代码调用了 main 函数，用 C 语言写的在main.c中，最终它们分别由 nasm 和 GCC 编译成<strong>可链接模块</strong>，由 <strong>LD 链接器</strong>链接在一起，形成可执行的程序文件<br>#include “vgastr.h”<br>void main()<br>{<br>printf(“Hello OS!”);<br>return;<br>} //printf 也不是应用程序库中的那个 printf 了，而是需要我们自己实现</p></blockquote><h5 id="屏幕显示"><a href="#屏幕显示" class="headerlink" title="屏幕显示"></a>屏幕显示</h5><blockquote><p>计算机屏幕显示往往是显卡的输出，显卡有很多形式：集成在主板的叫<strong>集显</strong>，做在 CPU 芯片内的叫<strong>核显</strong>，独立存在通过 PCIE 接口连接的叫<strong>独显</strong>，性能依次上升，价格也是</p><p>要在屏幕上显示字符，就要<strong>编程操作显卡</strong></p><p>无论什么显卡都支持一种叫 VESA 的标准，这种标准下有两种工作模式：字符模式和图形模式。显卡们为了兼容这种标准，不得不自己提供一种叫 <strong>VGABIOS 的固件程序</strong></p><ul><li>显卡的<strong>字符模式</strong></li></ul><p>它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 0xb8000 地址开始的内存中，每<strong>两个字节</strong>对应一个字符，其中一个字节是字符的 <strong>ASCII 码</strong>，另一个字节为字符的<strong>颜色值</strong></p><p><img src="/img/OS-2/2-3.jpg" alt="2-3"></p><p><em>C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的</em></p><p><strong>[vgastr.c]</strong></p><p>代码很简单, printf I函数直接调用了 strwrite图数,而_ strwrite函数正是将字符串 里每个字符依次定入到0Xxb8000地址开始的显存中,而p_ strdst每次加2,这也是为 了跳过字符的颜色信息的空间</p></blockquote><h5 id="编译–Hello-OS-bin"><a href="#编译–Hello-OS-bin" class="headerlink" title="编译–Hello OS.bin"></a>编译–Hello OS.bin</h5><blockquote><p>安装之前我们要进行系统编译（代码块编译最终链接成可执行的二进制文件）</p><ul><li>make </li></ul><p>make 是一个工具程序，它读取一个叫“Makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件</p><p><strong>[Makefile]</strong></p><p>makefile文件中规则是这样的:首先有一个或者多个构建目标称为“ target”;目标后面 紧跟着用于构建该目标所需要的文件,目标下面是构建该目标所需要的命令及参数</p><p>第一次构建目标后,下ー次执行make时,它会根据该目标所依赖的文件是否更新決定 是否编译该目标,如果所依赖的文件没有更新且该目标又存在,那么它便不会构建该目 示。这种特性非常有利于编译程序源代码</p><p><img src="/img/OS-2/2-4.jpg" alt="2-4"></p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><blockquote><p>需要GRUB在启动时找到Hello OS.bin，计算机才能在启动时加载它</p><ul><li>修改启动项</li></ul><p>经研究发现,GRUB在启动时会加载一个grub.cfg的文本文件,根据其中的内容执行 相应的操作,其中一部分内容就是启动项<br>GRUB首先会显示启动项到屏幕,然后让我们选择启动项,最后GRUB根据启动项对应的信息,加载OS文件到内存</p><p>[Hello OS的启动项]</p><p>menuentry ‘Helloos’ {<br>    insmod part_ msdos #GRUB加载分区模块识别分区<br>    insmod ext2  #GRUB加载ext文件系统模块识别ext文件系统<br>    set root=’hdo, msdos4’ #注意boot目录挂载的分区</p><p>​    multi boot2/boot/ Hellos.bin #GRUB以 multi boot2协议加载 Hellos.bin       boot #GRUB启动 Hellos.bin</p><p>}</p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4</p></blockquote><p><em>启动项放入/boot/grub/grub.cfg中</em></p><p><em>Hello OS.bin复制到/boot/</em></p></blockquote><h5 id="Do-——"><a href="#Do-——" class="headerlink" title="[Do]——"></a>[Do]——</h5><p><em>环境：Vmware Fusion—ubuntu18.04 虚拟机</em></p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><blockquote><p>$ sudo apt-get install  nasm</p><p>$ sudo apt-get install  make</p></blockquote><p>在Hello OS文件夹下执行</p><p>$ make -f Makefile |$ make all </p><p>—-&gt; HelloOS.bin</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><blockquote><ul><li>cp</li></ul><p>$ cp  HelloOS.bin /boot</p><p><img src="/img/OS-2/2-5.png" alt="2-5"></p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4<br><img src="/img/OS-2/2-6.png" alt="2-6"></p></blockquote><ul><li><p>启动项 /boot/grub/grub.cfg<br>$ sudo update-grub<br><img src="/img/OS-2/2-7.png" alt="2-7"></p></li><li><p>启动<br><img src="/img/OS-2/2-8.png" alt="2-8"><br><img src="/img/OS-2/2-9.png" alt="2-9"></p></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始-程序运行</title>
      <link href="2021/10/03/%5BOS%5D%E5%A7%8B/"/>
      <url>2021/10/03/%5BOS%5D%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><h5 id="「-程序编译装载执行-」"><a href="#「-程序编译装载执行-」" class="headerlink" title="「 程序编译装载执行 」"></a>「 程序编译装载执行 」</h5><blockquote><p> [1] Ken Thompson （one month）创造Unix</p><p> 又与[2]Dennis Ritchie 共同创造C语言</p></blockquote><blockquote><p>计算机<strong>硬件</strong>是无法直接运行这个 C 语言<strong>文本程序</strong>代码的</p><ul><li><p>需要 C 语言【编译器】，把这个代码编译成<strong>具体硬件平台</strong>的[二进制代码]</p></li><li><p>再由具体【操作系统】建立进程，把这个二进制文件装进其进程的<strong>内存空间</strong>中</p></li></ul><h5 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h5><blockquote><p>GCC 相关的工具链</p><p>$ gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld</p><p>GCC 只是完成编译工作的<strong>动程序</strong>，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作</p><p><img src="/img/OS-1/1-1.jpg" alt="1-1"></p><p>gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入<strong>头文件</strong>，替换<strong>宏</strong>。</p><p>gcc HelloWorld.c -S -c HelloWorld.s 编译：包含预处理，将 C 程序转换成<strong>汇编程序</strong>。</p><p>gcc HelloWorld.c -c HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成<strong>可链接的二进制程序</strong>。</p><hr><p>gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将<strong>可链接的二进制程序和其它别的库链接</strong>在一起，形成可执行的程序文件。</p></blockquote></blockquote><blockquote><p> [3] 阿兰图灵的图灵机</p><p> 图灵机是一个抽象的模型,它是这样的:有一条无限长的纸带,纸带上有无限个小格 子,小格子中写有相关的信息,纸带上有一个读头,<strong>读头能根据纸带小格子里的信息做 相关的操作并能来回移动</strong></p><p> [4] 冯诺伊曼的体系结构</p><p> 电子计算机使用<strong>二进制数制系统</strong>和<strong>储存程序</strong>,并按照程序顺序执行</p><ul><li>把程序和数据装入到计算机中;</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果;</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理;</li><li>根据需要控制程序走向,并能根据指令控制机器的各部件协调操作;</li><li> 能够按照要求将处理的数据结果显示给用户。</li></ul><p> 为了完成上述的功能,计算机必须具备五大基本组成部件</p><ul><li>装载数据和程序的输入设备</li><li>记住程序和数据的存储器</li><li>完成数据加工处理的运算器</li><li>控制程序执行的控制器</li><li>显示处理结果的输出设备</li></ul><p> Finally</p><blockquote><p><img src="/img/OS-1/1-2.jpg" alt="1-2"></p><p>我们发现读头不再来回移动了，而是靠<strong>地址总线</strong>寻找对应的“纸带格子”。读取写入数据由<strong>数据总线</strong>完成，而动作的控制就是<strong>控制总线</strong>的职责了</p></blockquote></blockquote><blockquote><h5 id="装载执行"><a href="#装载执行" class="headerlink" title="装载执行"></a>装载执行</h5><blockquote><ul><li>反汇编</li></ul><p>gcc -c -S HelloWorld</p><p><img src="/img/OS-1/1-3.jpg" alt="1-3"></p><p>第一列为地址；第二列为十六进制，表示<strong>真正装入机器中的代码数据</strong>；第三列是对应的<strong>汇编代码</strong>；第四列是相关<strong>代码的注释</strong>。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集</p><p><img src="/img/OS-1/1-4.jpg" alt="1-4"></p><p>现代电子计算机正是通过内存中的信息（<strong>指令和数据</strong>）做出相应的<strong>操作</strong>，并通过<strong>内存地址</strong>的变化，达到程序<strong>读取数据，控制程序流程</strong>（顺序、跳转对应该图灵机的读头来回移动）的功能</p></blockquote></blockquote><h5 id="「-详：物理机上程序运行的硬件环境-」"><a href="#「-详：物理机上程序运行的硬件环境-」" class="headerlink" title="「 详：物理机上程序运行的硬件环境 」"></a>「 详：物理机上程序运行的硬件环境 」</h5><blockquote><h5 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h5><p><img src="/img/OS-1/1-5.jpg" alt="1-5"></p><h6 id="PC计数器"><a href="#PC计数器" class="headerlink" title="PC计数器"></a>PC计数器</h6><p>通常,CPU上会有个寄存器,叫做PC计数器 [CPU能够计算出下一条需要执行的代码的地址，然后读取这个代码并执行(根据不同的CPU架构，PC计数器中的值可能不是直接的内存地址，而需要进行一点转换和计算) 通常情況下,程序都是顺序执行的 【1】但当遇到 <strong>跳转指令</strong> 时，PC计数器就会指向新的代码地址，从新的地址开始执行代码【2】除了跳转指令会改变PC计数器的值,CPU的 <strong>异常机制</strong> 也会改变PC计数器的值，跳转到异常处理程序，处理完毕之后再回来。CPU的异常机制是CPU架构设计的一个重要组成部分。典型的异常是由<strong>硬件触发</strong>的中断。我们每次敲打键盘,都会触发一个中断,处理 完毕以后会再接着运行原来的程序。也有的时候,中断可以由<strong>软件触发</strong>,比如当你Debug程序的时候,你可以控制着程序一条一条代码的执行,这也是利用了中断机制 ]</p><h6 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h6><p>’操作码的<strong>助记符、源操作数</strong>和<strong>目标操作数</strong>‘</p><blockquote><p>movl  -4(%rbp)， %eax </p><p>addl  $10， %eax </p><p>mov %eax， -r (%rbp)</p><ul><li><p>movl指令,movl能够把一个整数从一个地方<strong>拷贝</strong>到另一个地方。这里 是从一个内存地址取出一个值,放到%eax寄存器,而这个内存地址是%rpb寄存器的值減去4;</p></li><li><p>addl指令,它把常数10<strong>加</strong>到%eax寄存器上</p></li><li><p>又是一个mov指令,这次是把%eax寄存器的值又写回第一行的那个内存地址</p><p>（以上三条代码以机器码的形式放在内存）</p></li></ul></blockquote><p>CPU根据PC计数器的值，从【内存】中取指令读进CPU</p><blockquote><p>指令被读入内存之后会有一个解码的过程，就是把操作码、源操作数、目标操作数拆解出来，用于后续处理（解码 是由CPU内部的一个功能单元完成的）</p></blockquote><p>CPU从【高速缓存】中读入代码和数据</p><blockquote><p>高速缓存分 Instruction Cache 和 Data Cache</p><p>只有高速缓存中没有这些代码和数据的时候 才从内存读取</p><ul><li>高速缓存</li></ul><p>高速缓存是内存与CPU之间的缓冲区 </p><p>当CPU从内存中读取数据的时候，其实是从高速缓存读取了；如果在高速缓存中没有（没有命中），CPU会把这个数据旁边的数据都读入高速缓存，这样下一次可以从高速缓存读取</p><p>高速缓存分多级，L1～L3 速度从高到低，容量反之；低速的一般是多核共享，高速的是每核独享</p></blockquote><p>【寄存器】是CPU做运算的操作区</p><blockquote><p>CPU把数据加载到寄存器，然后在寄存器内进行运算</p><p>寄存器速度大概是内存的100倍</p><ul><li>特殊寄存器</li></ul><p>在CPU的设计中,有些寄存器是有特定用途的,比如PC计数器用于计算代码地址,EFlags寄存器用于保存一些运算结果产生的状态等</p><ul><li>通用寄存器</li></ul><p>还有一些寄存器叫做通用寄存器,它们可以被我们的代码所使用,进行加减乘除等各种计 算。在把程序编译成汇编代码的时候,我们要尽量去利用这些通用寄存器来运算。但如果寄存器不够用,就需要临时保存到内存中,把寄存器的空间腾出来。</p></blockquote><p>MMU</p><blockquote><p>CPU获得的地址先经过MMU翻译，得到真实的物理内存地址，然后去高速缓存取，没有才从内存加载</p></blockquote><p>ALU</p><blockquote><p>算数逻辑单元进行计算</p></blockquote><h5 id="CPU内部的功能单元和流水线"><a href="#CPU内部的功能单元和流水线" class="headerlink" title="CPU内部的功能单元和流水线"></a>CPU内部的功能单元和流水线</h5><p>「 功能单元 」</p><blockquote><p>CPU的微架构</p><p><img src="/img/OS-1/1-6.png" alt="1-6"></p><p>指令高速缓存中的指令会被解码,解码后变成<strong>微指令</strong></p><p>X86使用的指令属于复杂指令集(CISC),CISC会针对特定的功能来设计一些指令,所以指令的执行效率会较高,就像我们为了某个应用目的专门写一个程序来处理那样。但复杂指令集也有坏处,就是指令的条数太多了,导致硬件设计会变得复杂,也不容易利用我们下面将要讲到的流水线的优势。所以,其实现代使用CISC的CPU,在内部设上也借鉴了RISC的优点,把复杂的指令拆解成了简单的指令,或者叫做微指令,也就是图中的uop</p><p>微指令会排成队列去执行任务,它们会到达一个调度器,由调度器调度不同的处理单元去 完成不同的任务。调度器通过不同的端口(Port)来调度任务,不同的功能单元则在端口上接收任务。有的单元负责<strong>保存数据</strong>,有的单元负责加载数据,这些单元都会接到高速缓存上。还有几个端口是专门做<strong>计算</strong>的。不同的计算任务又分别由不同的计算单元承担,比如ALU是做算术运算的,LEA是做地址运算的,FMA是做浮点数运算的,等等</p></blockquote><p>「 流水线 」</p><blockquote><p>不同的CPU,其内部功能单元的划分是不同的。但总的来说,在执行一条指令的时候，CPU内部实际是多个单元按顺序去处理的,这被叫做<strong>指令流水线</strong></p><p>不同CPU的流水线设计是不同的,有的分5个步骤,有的分成8个、10个甚至更多个步骤采用流水线技术最大的好处,就是我们不用等一条指令完全执行完毕,才去执行第二条指 令。假设每条指令需要用到5个功能单元,分成5个步骤。那么在第一条指令的第一个 步骤执行完毕以后,第一个功能单元就空出来了,就可以处理第二条指令了。总的来说相当于有5条指令在并行运行</p><p><img src="/img/OS-1/1-7.png" alt="1-7"></p><p>实际上的执行过程并没有这么理想,因为不同的指令会用到不同的功能单元。比 如上面示例程序的三条指令中,addl指令用到了ALU单元,而其他两条指令就没用到。 而且,每个功能单元所需要的时钟周期也是不同的。所以,各条指令在执行过程中就会出 现等待的情况</p></blockquote><p>BPU分支预测单元</p><blockquote><p>分支预测单元(BPU),尽量争取能准确地预测接下来的分支。如果预测失败,那么CPU就会把流水线清空,把已经完成的计算的结果废弃掉<br>流水线技术可以看做是<strong>指令级的一种并行技术</strong>,是一种微观的并行技术</p></blockquote><h5 id="并行和并发的硬件支持"><a href="#并行和并发的硬件支持" class="headerlink" title="并行和并发的硬件支持"></a>并行和并发的硬件支持</h5><blockquote><p>通过多颗CPU支持多程序的并行执行，每个CPU拥有自己独立的寄存器，各自读取指令执行</p><p>一颗CPU通过多核，实现程序的并行（有的CPU还支持超线程，在一个内核也可以运行多个程序，每个程序有独立的寄存器，互不干扰）</p><p>一颗单核CPU也可以通过时间片轮转技术，使得这个CPU运行多个任务，这种让CPU定期停止，执行另一个任务叫做并发</p></blockquote></blockquote><h5 id="「-详：物理机上程序运行的软件环境-」"><a href="#「-详：物理机上程序运行的软件环境-」" class="headerlink" title="「 详：物理机上程序运行的软件环境 」"></a>「 详：物理机上程序运行的软件环境 」</h5><blockquote><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><blockquote><p>操作系统的一个重要功能就是<strong>管理内存</strong>，它会将<strong>内存虚拟化</strong>，并进行内存访问的权限管理</p><h6 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h6><p>虚拟化就是让每个<strong>进程</strong>都有一个自己可以用的<strong>寻址空间</strong>,不过这些地址是假的地址。但就这些假地址,我们通过指令发给CPU,CPU也是认的。因为CPU中有一个内存管理单元,缩写是MMU,它能够根据这个逻辑地址,计算出在内存里真实的物理地址。MMU还可以跟操作系统配合,设置每个内存页面的权限,包括是否可读、可写和可执行</p><p>这种逻辑地址与物理地址转换的功能,对我们做编译很有用。我们的程序编译成目标代码的时候,里面的每个<strong>函数、常量和全局变量的地址</strong>,都是确定的。这样,在操作系统加载了可执行程序以后,就可以正确地调用每个函数,访问每个数据了<br>在虚拟化机制下,只有你用到某个地址,操作系统才会为这个地址分配真实的物理内存。这些<strong>物理内存一般划分成页来管理</strong>，MMU会根据这些分页信息把逻辑地址转换成物理地址</p><hr><h6 id="栈内申请内存"><a href="#栈内申请内存" class="headerlink" title="栈内申请内存"></a>栈内申请内存</h6><blockquote><p>(在X64架构下，栈顶指针使用的是rsp寄存器)</p><p>但其实,这时候并没有真正分配内存, 你只是改变了寄存器的值而已。但如果你访问栈里的某个地址,而且这个地址又没有被分配物理的内存页,那么CPU在访问内存的时候就会知道这里出错了。它就会触发一个<strong>缺页中断</strong>,跳转到中断处理程序,去分配页面。分配完毕以后,又跳回原来的程序接着执行</p><p>「CPU在处理中断的时候,要<strong>保护当前的现场</strong>,比如各个寄存器的状态。否则,如果各个寄存器的值被弄乱了,原来的程序就没法执行了。然后在返回原来的程序的时候,CPU要<strong>恢复现场</strong>」</p><p>rsp只是起到一个标记作用,是我们的程序跟操作系统之间的一个约定。我们<strong>只要修改了rsp里的值,操作系统就要保证给我们提供足够的内存</strong>。如果你违背了这个约定去乱访问一些地址,在MM和操作系统的配合下,也会被识别出来,就会报<strong>内存访问的错误</strong></p><p>「特别的」</p><p>有的操作系统就比较为程序着想了,它规定你可以访问栈顶之外的一定范围内的内存。比如, Linux和大多数类Unix的系统都遵循 System V AMD64 ABI,它规定可以访问栈顶之外的128个字节范围内的内存。<br>好处是,对于程序中的<strong>叶子函数</strong>,也就是这个函数没有<strong>调用其他函数</strong>, 并且它所使用的数据不会超过128个字节的情況,我们根本不需要去建立栈桢,也就省去了把栈顶指针的值保存到内存,修改栈顶指针,最后再从内存中恢复J顶指针这一系列操作,这样就节省了大量的内存读写时间,让系统性能得到优化</p></blockquote><h6 id="堆中申请内存"><a href="#堆中申请内存" class="headerlink" title="堆中申请内存"></a>堆中申请内存</h6><blockquote><p>在堆中申请内存也是一样,也不是真实的分配,只是<strong>提供了一些标记信息,之后可供</strong><br><strong>MMU使用而已</strong>**</p></blockquote><hr><p>「内存布局」</p><blockquote><p><img src="/img/OS-1/1-8.jpg" alt="1-8"></p><p>代码段(.text)和数据段(包括.data和.bss)是从<strong>可执行文件直接加载进内存</strong>的可执行文件中提前计算好的函数、常量和全局变量的地址,也就变成了内存中的地址<br>另外两个重要的区域是栈和堆 栈是从高地址向低地址延伸的,而堆则是从低地址向高地 址延伸的（但是,在不同的操作系统中,上图中每个部分的具体地址都是不大相同的,比如<br>macos和 Linux的就不同）</p></blockquote><p>「程序」</p><p>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;</p><p>//全局变量<br>int global_a = 10;<br>char * global_b = “hello”;</p><p>int main(int argc, char** argv){<br>printf(“命令行参数/&quot;address&quot;的地址:\t0x%12lX\n”,(size_t)argv[0]);<br>printf(“命令行参数/argv数组的地址:  \t0x%12lX\n”, (size_t)argv);<br>printf(“栈/参数argc的地址:         \t0x%12lX\n”, (size_t)&amp;argc);<br>printf(“栈/参数argv的地址:         \t0x%12lX\n”, (size_t)&amp;argv);</p><p>int local_a = 20;<br>printf(“栈/local_a的地址:         \t0x%12lX\n”, (size_t)&amp;local_a);</p><p>int * local_b = (int*)malloc(sizeof(int));<br>printf(“栈/local_b的地址:         \t0x%12lX\n”, (size_t)&amp;local_b);<br>printf(“堆/local_b指向的地址:      \t0x%12lX\n”, (size_t)local_b);<br>free(local_b);</p><p>printf(“data段/global_b的地址:    \t0x%12lX\n”, (size_t)&amp;global_b);</p><p>printf(“data段/global_a的地址:    \t0x%12lX\n”, (size_t)&amp;global_a);</p><p>printf(“text段/&quot;hello&quot;的地址:    \t0x%12lX\n”, (size_t)global_b);</p><p>printf(“text段/main函数的地址:     \t0x%12lX\n”, (size_t)main);<br>}</p><blockquote><p><img src="/img/OS-1/1-9.jpg" alt="1-9"></p><p>你看这张图，最上面的是命令行参数</p><p>main 函数的参数 argv[0]，实际上是操作系统提供的一个命令行参数，也就是可执行文件的名称，而 argv[0]的值，就是字符串“address”的地址</p><p>参数是被放在栈里的，第一个参数排在前面，第二个参数排在后面。其中第二个参数是 argv，它的值是指向一个参数数组</p><p>两个本地变量 local_a 和 local_b，它们也是放在栈里的。其中 local_b 是一个指针，指向堆里申请的一小块内存的地址</p><p>两个全局变量，它们存在.data 段。其中 global_b 是一个指针，指向一个字符串常量“hello”</p><p>最后是.text 段，这里有字符串常量“hello”，也有 main 函数对应的机器码</p><p>（这样小的程序，都涉及了这么多个地址。全局变量、常数和代码的地址是由编译和链接程序确定的，命令行参数的地址是由操作系统分配的，而函数参数、本地变量和从堆中申请的内存，是在运行期分配的）</p></blockquote><p>「不同语言程序的布局」</p><blockquote><p> C、C++ 这些静态编译的语言，要提前编译成可执行文件，把可执行文件加载到内存以后，内存布局就是上面的样子。其中，可执行文件的格式、如何加载到内存、每个段的起始地址是多少、如何让程序能够访问环境变量和命令行参数、调用系统 API 时的调用约定等等，都是由操作系统的 ABI 规定的。</p><p>但也有的语言，特别是带有即时编译能力的语言，以及想要实现自己的并发机制的语言，会用更灵活的方式来使用内存。我拿即时编译的情况举个例子。现代很多语言是编译成机器码运行的，但却不是提前编译的，而是在运行时编译的，典型的就是 Java 和基于 V8 的 JavaScript。既然是即时编译成机器码的，那也就不可能像 C 语言那样提前计算好每个函数的代码地址，并且放到内存中的文本段，而是<strong>动态地从堆中申请内存，来保存这些机器码</strong>，并且运行它们</p></blockquote></blockquote><h5 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h5><blockquote><p>任务管理,我们主要指的就是<strong>多任务的处理</strong>,现代计算机都支持多任务的处理</p><p>CPU为多任务处理所提供的硬件支撑,通过多处理器、多核以及超线程技术,可以让多个任务并行地执行；在硬件能力较低的情況下,哪怕我们只有一条真实 的执行线索,我们仍然可以借助硬件的中断机制(主要是时钟中断)让多个任务分时执 行,从而实现并发机制</p><p>「 操作系统的支持下的多任务处理 」</p><blockquote><p>因为操作系统在<strong>硬件提供的能力</strong>的基础上，封装出了进程、线程这样的并发调度机制，让我们可以忽略很多任务管理中的细节。比如，进程和线程都对应着一些上下文信息，像寄存器之类的信息，等等。在进行任务的切换时，操作系统会为我们的程序自动保存和恢复这些上下文信息，调度过程对我们的程序来说是透明的，编译器不需要做什么额外的工作</p><p>但是，云计算时代的到来，使得并发任务越来越多，仅仅靠操作系统级提供的并发机制已经不能满足我们的要求了。所以，在语言层面，<strong>各个语言也开始提供并发机制</strong>，比如协程机制、Actor 机制等</p></blockquote><p>「 语言层面上实现的并发机制 」</p><blockquote><p>在语言层面上实现的并发机制，和操作系统级别的机制，是有所区别的</p><p>操作系统的多任务机制，一般是<strong>抢占式的</strong>。也就是说，操作系统可以强行把当前任务调度走，去执行其他任务，像 Linux 和 Windows 系统，都是抢占式的。这个过程需要用到中断机制，由<strong>操作系统内核态</strong>的代码去处理中断。</p><p>而用户的程序是运行在用户态的，所以由计算机语言本身支持的并发机制，一般是<strong>协作式</strong>的，因为我们没有办法打断别的任务的运行。所以，如果一个协程一直不停下来，不主动交出 CPU 来，我们通常是没有办法干涉的。但是，编译器和运行时配合，我们仍然是可以做一些工作，避免某些任务长时间占据 CPU。比如，Erlang 是<strong>基于虚拟机运行</strong>的，这时候虚拟机就像一个物理的 CPU 一样，检查某个并发任务执行了多长时间，需要时把它调度走。而 Go 语言的 Goroutine，是编译成本地代码运行的<strong>，并没有一个解释器来控制代码的执行</strong>，但它也会在编译后的程序里插入一些代码，用于并发调度。程序在执行到这里的时候，运行时会去检查 Goroutine 是否超时了，超时就把它挂起来，或者把一些等候过久的任务挪到比较空闲的线程去执行。并且，在语言级实现的多任务机制，也涉及任务的数据和状态信息的管理问题。比如，操作系统中，只为每个线程准备了一个栈，随着函数的逐级调用，栈会不停地伸缩。而采用了协程以后，有多个并发的任务在执行，每个任务都会形成自己的调用栈。这个时候，<strong>语言的运行时就要打破操作系统传统的栈管理机制，形成自己的管理机制</strong>。</p></blockquote></blockquote><h5 id="ABI（Application-Binary-Interface）"><a href="#ABI（Application-Binary-Interface）" class="headerlink" title="ABI（Application Binary Interface）"></a>ABI（Application Binary Interface）</h5><blockquote><p>应用程序的二进制接口。对谁的接口呢？对操作系统的</p><p>像 Linux 和 macOS 这些类 Unix 的操作系统，遵循的都是 SYSTEM V APPLICATION BINARY INTERFACE</p><p>ABI 文档里包含的内容很多，基本上，要让一个二进制程序能够在某个操作系统上跑起来所需要的所有信息，都在这里规定了。比如：对二进制文件格式的规定；如何加载程序，以及实现动态链接；在系统里可以用到的标准库；</p><p>还有一些内容，要根据所采用的 CPU 架构来做规定。比如，在针对 AMD64 架构的补充手册（System V Application Binary Interface AMD64 Architecture Processor Supplement）中，有一个 3.2 节，标题是函数调用顺序（Function Calling Sequence），就规定了栈桢的结构、如何传递参数、哪些寄存器是由被调用者负责保护的等等，这些信息在我们后面生成汇编代码的时候特别有用。</p><p>这些规定，有些是我们必须遵守的，比如在调用函数时对栈桢的内存对齐的规定，否则操作系统就会报错。有些呢，我们语言的设计者可以不用严格遵守，为我们的语言发明我们自己的机制，就像函数如何传参、如何接收返回值等调用约定。比如，Go 语言支持多个返回值，显然就跟 C 语言的机制是不同的。但是，如果我们要调用系统的标准库，那么就必须遵守 ABI 里所规定的调用约定才行</p></blockquote></blockquote><p><em>参考《操作系统实战45讲》《手把手带你写一门编程语言》</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研途</title>
      <link href="2021/09/16/%E7%A0%94%E9%80%94/"/>
      <url>2021/09/16/%E7%A0%94%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><blockquote><p> 还有<strong>197</strong>天<br></p><p> 以一个计算机专业的身份毕业<br></p></blockquote><br><br><br>  *一穷二白的年纪 至少还有微薄的工资｜充足的时间｜免费的网络资源｜可以记录生活的设备*]]></content>
      
      
      
        <tags>
            
            <tag> yan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
