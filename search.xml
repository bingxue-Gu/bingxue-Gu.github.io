<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>始-Hello OS</title>
      <link href="2021/10/03/%5BOS%5DHello/"/>
      <url>2021/10/03/%5BOS%5DHello/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p><em>写操作系统要用汇编和C语言,现有的商业操作系统都是用这两种语言开发出来的</em></p><h5 id="PC机的引导流程"><a href="#PC机的引导流程" class="headerlink" title="PC机的引导流程"></a>PC机的引导流程</h5><blockquote><p>借用一下 GRUB 引导程序</p><p>只要我们的 PC 机上安装了 Ubuntu Linux 操作系统，GRUB 就已经存在</p><p><img src="/img/OS-2/2-1.png" alt="2-1"></p><p>OS 引导流程</p><p><img src="/img/OS-2/2-2.jpg" alt="2-2"></p><ul><li>PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的（掉电也能保存）</li></ul><blockquote><p>ROM是只读内存（Read-Only Memory）此内存的制造成本较低，常用于电脑中的开机启动</p></blockquote><ul><li>PC 机上电后的<strong>第一条指令</strong>就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区<strong>数据</strong>，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处<strong>执行指令</strong>，在我们这里的情况下就是 GRUB 引导程序</li></ul></blockquote><h5 id="OS引导汇编"><a href="#OS引导汇编" class="headerlink" title="OS引导汇编"></a>OS引导汇编</h5><blockquote><ul><li>为什么不能直接用 C？</li></ul><p>C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要<strong>用栈</strong>（栈由 CPU 特定的<strong>栈寄存器指向</strong>，所以我们要先用汇编代码处理好这些 C 语言的工作环境）</p><p><strong>[entry.asm]</strong></p><blockquote><ol><li>代码 1~40 行，用汇编定义的 GRUB 的多引导协议头，其实就是一定格式的数据，我们的 Hello OS 是用 GRUB 引导的，当然要遵循 GRUB 的多引导协议标准，<strong>让 GRUB 能识别我们的 Hello OS</strong>  之所以有两个引导头，是为了兼容 GRUB1 和 GRUB2。</li><li>代码 44~52 行，<strong>关掉中断，设定 CPU 的工作模式</strong>。你现在可能不懂，没事儿，后面 CPU 相关的课程我们会专门再研究它。</li><li>代码 54~73 行，<strong>初始化 CPU 的寄存器和 C 语言的运行环境</strong>。</li><li>代码 78~87 行，GDT_START 开始的，是 <strong>CPU 工作模式所需要的数据</strong>，同样，后面讲 CPU 时会专门介绍。</li></ol></blockquote></blockquote><h5 id="OS主函数"><a href="#OS主函数" class="headerlink" title="OS主函数"></a>OS主函数</h5><blockquote><p><strong>[main.c]</strong></p><p>汇编代码调用了 main 函数，用 C 语言写的在main.c中，最终它们分别由 nasm 和 GCC 编译成<strong>可链接模块</strong>，由 <strong>LD 链接器</strong>链接在一起，形成可执行的程序文件<br>#include “vgastr.h”<br>void main()<br>{<br>printf(“Hello OS!”);<br>return;<br>} //printf 也不是应用程序库中的那个 printf 了，而是需要我们自己实现</p></blockquote><h5 id="屏幕显示"><a href="#屏幕显示" class="headerlink" title="屏幕显示"></a>屏幕显示</h5><blockquote><p>计算机屏幕显示往往是显卡的输出，显卡有很多形式：集成在主板的叫<strong>集显</strong>，做在 CPU 芯片内的叫<strong>核显</strong>，独立存在通过 PCIE 接口连接的叫<strong>独显</strong>，性能依次上升，价格也是</p><p>要在屏幕上显示字符，就要<strong>编程操作显卡</strong></p><p>无论什么显卡都支持一种叫 VESA 的标准，这种标准下有两种工作模式：字符模式和图形模式。显卡们为了兼容这种标准，不得不自己提供一种叫 <strong>VGABIOS 的固件程序</strong></p><ul><li>显卡的<strong>字符模式</strong></li></ul><p>它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 0xb8000 地址开始的内存中，每<strong>两个字节</strong>对应一个字符，其中一个字节是字符的 <strong>ASCII 码</strong>，另一个字节为字符的<strong>颜色值</strong></p><p><img src="/img/OS-2/2-3.jpg" alt="2-3"></p><p><em>C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的</em></p><p><strong>[vgastr.c]</strong></p><p>代码很简单, printf I函数直接调用了 strwrite图数,而_ strwrite函数正是将字符串 里每个字符依次定入到0Xxb8000地址开始的显存中,而p_ strdst每次加2,这也是为 了跳过字符的颜色信息的空间</p></blockquote><h5 id="编译–Hello-OS-bin"><a href="#编译–Hello-OS-bin" class="headerlink" title="编译–Hello OS.bin"></a>编译–Hello OS.bin</h5><blockquote><p>安装之前我们要进行系统编译（代码块编译最终链接成可执行的二进制文件）</p><ul><li>make </li></ul><p>make 是一个工具程序，它读取一个叫“Makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件</p><p><strong>[Makefile]</strong></p><p>makefile文件中规则是这样的:首先有一个或者多个构建目标称为“ target”;目标后面 紧跟着用于构建该目标所需要的文件,目标下面是构建该目标所需要的命令及参数</p><p>第一次构建目标后,下ー次执行make时,它会根据该目标所依赖的文件是否更新決定 是否编译该目标,如果所依赖的文件没有更新且该目标又存在,那么它便不会构建该目 示。这种特性非常有利于编译程序源代码</p><p><img src="/img/OS-2/2-4.jpg" alt="2-4"></p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><blockquote><p>需要GRUB在启动时找到Hello OS.bin，计算机才能在启动时加载它</p><ul><li>修改启动项</li></ul><p>经研究发现,GRUB在启动时会加载一个grub.cfg的文本文件,根据其中的内容执行 相应的操作,其中一部分内容就是启动项<br>GRUB首先会显示启动项到屏幕,然后让我们选择启动项,最后GRUB根据启动项对应的信息,加载OS文件到内存</p><p>[Hello OS的启动项]</p><p>menuentry ‘Helloos’ {<br>    insmod part_ msdos #GRUB加载分区模块识别分区<br>    insmod ext2  #GRUB加载ext文件系统模块识别ext文件系统<br>    set root=’hdo, msdos4’ #注意boot目录挂载的分区</p><p>​    multi boot2/boot/ Hellos.bin #GRUB以 multi boot2协议加载 Hellos.bin       boot #GRUB启动 Hellos.bin</p><p>}</p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4</p></blockquote><p><em>启动项放入/boot/grub/grub.cfg中</em></p><p><em>Hello OS.bin复制到/boot/</em></p></blockquote><h5 id="Do-——"><a href="#Do-——" class="headerlink" title="[Do]——"></a>[Do]——</h5><p><em>环境：Vmware Fusion—ubuntu18.04 虚拟机</em></p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><blockquote><p>$ sudo apt-get install  nasm</p><p>$ sudo apt-get install  make</p></blockquote><p>在Hello OS文件夹下执行</p><p>$ make</p><p>—-&gt; HelloOS.bin</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><blockquote><ul><li>cp</li></ul><p>$ cp  HelloOS.bin /boot</p><p><img src="/img/OS-2/2-5.png" alt="2-5"></p><ul><li>boot目录挂载分区</li></ul><blockquote><p>Linux 终端下 $ df /boot/</p><p>sada4表示为hdo, msdos4<br><img src="/img/OS-2/2-6.png" alt="2-6"></p></blockquote><ul><li><p>启动项 /boot/grub/grub.cfg<br>$ sudo update-grub<br><img src="/img/OS-2/2-7.png" alt="2-7"></p></li><li><p>启动<br><img src="/img/OS-2/2-8.png" alt="2-8"><br><img src="/img/OS-2/2-9.png" alt="2-9"></p></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始-程序运行</title>
      <link href="2021/10/03/%5BOS%5D%E5%A7%8B/"/>
      <url>2021/10/03/%5BOS%5D%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><blockquote><p> [1] Ken Thompson （one month）创造Unix</p><p> 又与[2]Dennis Ritchie 共同创造C语言</p></blockquote><blockquote><p>计算机<strong>硬件</strong>是无法直接运行这个 C 语言<strong>文本程序</strong>代码的</p><ul><li><p>需要 C 语言【编译器】，把这个代码编译成<strong>具体硬件平台</strong>的[二进制代码]</p></li><li><p>再由具体【操作系统】建立进程，把这个二进制文件装进其进程的<strong>内存空间</strong>中</p></li></ul><h5 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h5><blockquote><p>GCC 相关的工具链</p><p>$ gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld</p><p>GCC 只是完成编译工作的<strong>动程序</strong>，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作</p><p><img src="/img/OS-1/1-1.jpg" alt="1-1"></p><p>gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入<strong>头文件</strong>，替换<strong>宏</strong>。</p><p>gcc HelloWorld.c -S -c HelloWorld.s 编译：包含预处理，将 C 程序转换成<strong>汇编程序</strong>。</p><p>gcc HelloWorld.c -c HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成<strong>可链接的二进制程序</strong>。</p><hr><p>gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将<strong>可链接的二进制程序和其它别的库链接</strong>在一起，形成可执行的程序文件。</p></blockquote></blockquote><blockquote><p> [3] 阿兰图灵的图灵机</p><p> 图灵机是一个抽象的模型,它是这样的:有一条无限长的纸带,纸带上有无限个小格 子,小格子中写有相关的信息,纸带上有一个读头,<strong>读头能根据纸带小格子里的信息做 相关的操作并能来回移动</strong></p><p> [4] 冯诺伊曼的体系结构</p><p> 电子计算机使用<strong>二进制数制系统</strong>和<strong>储存程序</strong>,并按照程序顺序执行</p><ul><li>把程序和数据装入到计算机中;</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果;</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理;</li><li>根据需要控制程序走向,并能根据指令控制机器的各部件协调操作;</li><li> 能够按照要求将处理的数据结果显示给用户。</li></ul><p> 为了完成上述的功能,计算机必须具备五大基本组成部件</p><ul><li>装载数据和程序的输入设备</li><li>记住程序和数据的存储器</li><li>完成数据加工处理的运算器</li><li>控制程序执行的控制器</li><li>显示处理结果的输出设备</li></ul><p> Finally</p><blockquote><p><img src="/img/OS-1/1-2.jpg" alt="1-2"></p><p>我们发现读头不再来回移动了，而是靠<strong>地址总线</strong>寻找对应的“纸带格子”。读取写入数据由<strong>数据总线</strong>完成，而动作的控制就是<strong>控制总线</strong>的职责了</p></blockquote></blockquote><blockquote><h5 id="装载执行"><a href="#装载执行" class="headerlink" title="装载执行"></a>装载执行</h5><blockquote><ul><li>反汇编</li></ul><p>gcc -c -S HelloWorld</p><p><img src="/img/OS-1/1-3.jpg" alt="1-3"></p><p>第一列为地址；第二列为十六进制，表示<strong>真正装入机器中的代码数据</strong>；第三列是对应的<strong>汇编代码</strong>；第四列是相关<strong>代码的注释</strong>。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集</p><p><img src="/img/OS-1/1-4.jpg" alt="1-4"></p><p>现代电子计算机正是通过内存中的信息（<strong>指令和数据</strong>）做出相应的<strong>操作</strong>，并通过<strong>内存地址</strong>的变化，达到程序<strong>读取数据，控制程序流程</strong>（顺序、跳转对应该图灵机的读头来回移动）的功能</p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筑-空中楼阁</title>
      <link href="2021/09/27/%E7%AD%91/"/>
      <url>2021/09/27/%E7%AD%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p><em>物理资源的逻辑抽象</em></p><p><em>从底层向应用层</em></p><blockquote><p>计算机是可以自动执行任意的逻辑或算数指令序列的机器</p><p>计算机 = 一台自动执行的机器 + <strong>一张说明书（程序）</strong>+ 一张白纸（存</p><p>储）</p><h4 id="一张说明书"><a href="#一张说明书" class="headerlink" title="一张说明书"></a>一张说明书</h4><ul><li>程序(说明书)</li></ul><blockquote><p>程序 = 算法 + 数据结构</p><p>程序是用来指导计算机应该做些什么事情的一张<strong>说明书</strong>，只有在程序的</p><p>帮助下，计算机才知道应该如何执行</p><p><strong>程序的最终目的是用来处理数据的</strong>。</p><p>一个程序可能没有输入，但是一定会有输出。不然就是浪费电</p></blockquote><ul><li>算法</li></ul><blockquote><p>算法是程序的逻辑</p></blockquote><ul><li>数据结构</li></ul><blockquote><p>数据结构是计算机中存储、组织数据的方式，让计算机高效的处理数据</p></blockquote><ul><li>语言</li></ul><blockquote><p>语言是程序的表示方法</p></blockquote><h4 id="一台机器"><a href="#一台机器" class="headerlink" title="一台机器"></a>一台机器</h4><ul><li>CPU</li></ul><blockquote><ol><li><p>知道程序（说明书）存储的位置</p></li><li><p>知道自己运行到说明书的什么地方</p></li><li><p>可以读取直接自己下一条应该根据（程序）说明书干什么事情</p></li><li><p>能干的事情：算数逻辑运算，或者跳转（说明书分支）</p></li></ol></blockquote><h4 id="一张白纸"><a href="#一张白纸" class="headerlink" title="一张白纸"></a>一张白纸</h4><ul><li>CPU 的寄存器 (Register)</li></ul><blockquote><p>CPU 本身有数据的缓存地方，叫做寄存器</p><p>数据只有在寄存器里面，才可以被 CPU 进行运算（易失）</p><p>读取寄存器的延迟时间：1</p><p>寄存器的大小：几十个数字</p></blockquote><ul><li>高速缓存 (Cache)</li></ul><blockquote><p>高速缓存是 CPU 的一个部分（不同于寄存器），由硬件进行管理，可以</p><p>忽略看不见（易失)</p><p>读取高速缓存的延迟时间：10-50</p><p>高速缓存的大小：10M 左右</p></blockquote><ul><li><p>主存 (内存，Main memory)</p><blockquote><p>主存是最大的 CPU 可以<strong>直接调用</strong>的最大的存储设备</p><p>所有的程序和数据运行的时候都会缓存在主存里面(易失)</p><p>读取主存的延迟时间：100+</p><p>主存的大小：1G-100G</p></blockquote></li><li><p>硬盘 (Hard disk)</p><blockquote><p>最大的存储设备(非易失)</p><p>读取硬盘的延迟时间：1000+</p><p>硬盘的大小：100G-1T</p></blockquote></li></ul></blockquote><p><em>一穷二白的年纪 至少还有微薄的工资｜充足的时间｜免费的网络资源｜可以记录生活的设备</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> yan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研途</title>
      <link href="2021/09/16/%E7%A0%94%E9%80%94/"/>
      <url>2021/09/16/%E7%A0%94%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/yan.jpg" alt="yan"></p><p>还有<strong>197</strong>天<br><br>以一个计算机专业的身份毕业<br></p><br><br><br>  *一穷二白的年纪 至少还有微薄的工资｜充足的时间｜免费的网络资源｜可以记录生活的设备*]]></content>
      
      
      
        <tags>
            
            <tag> yan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
